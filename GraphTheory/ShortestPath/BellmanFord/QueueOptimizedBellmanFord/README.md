#### 队列优化版 Bellman-Ford 算法

朴素版 BellmanFord 算法每次对所有的边进行松弛，但真正有效的松弛，是基于已经计算过的顶点做的松弛

基于以上思路，一般使用队列记录上一次松弛的时候更新过的节点

* **核心思想**：动态规划。通过不断**松弛**所有的边，来逐步逼近最短路径。最多需要进行 `V-1` 轮松弛
* **前提条件**：图中**不能有负权环**。因为如果存在负权环，则可以无限次地绕环走，使得路径总权值无限小
* **时间复杂度**：平均时间复杂度为O(K * E)，K表示队列的最大长度
* **空间复杂度**：O(V)，minDist[] 数组，minDits[i] 表示起点到顶点 i 的最短距离

算法步骤：

1. 初始化：将源点的距离设为0，其他所有点的距离设为无穷大
2. 对图中的所有边进行松弛操作，重复此过程 `V-1` 次松弛操作：对于每条边 `(u, v)`，如果 `dist[u] + w(u, v) < dist[v]`，则更新 `dist[v] = dist[u] + w(u, v)`
3. 检查负权环：再进行一次所有边的松弛操作。如果任何顶点的距离还能被更新，则说明图中存在从源点可达的负权环

优势：

* 可以处理负权边
* 能够检测出图中是否存在负权环

注意点：

* 虽然队列可以避免无效的松弛操作，但是入队出队操作也比较耗时
