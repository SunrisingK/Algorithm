#### Bellman-Ford 算法

这是一个更加通用的算法，可以处理负权边

* **核心思想**：动态规划。通过不断**松弛**所有的边，来逐步逼近最短路径。最多需要进行 `V-1` 轮松弛
* **前提条件**：图中**不能有负权环**。因为如果存在负权环，则可以无限次地绕环走，使得路径总权值无限小
* **时间复杂度**：O(V * E)，比Dijkstra慢
* **空间复杂度**：O(V)，minDist[] 数组，minDits[i] 表示起点到顶点 i 的最短距离

算法步骤：

1. 初始化：将源点的距离设为0，其他所有点的距离设为无穷大
2. 对图中的所有边进行松弛操作，重复此过程 `V-1` 次松弛操作：对于每条边 `(u, v)`，如果 `dist[u] + w(u, v) < dist[v]`，则更新 `dist[v] = dist[u] + w(u, v)`
3. 检查负权环：再进行一次所有边的松弛操作。如果任何顶点的距离还能被更新，则说明图中存在从源点可达的负权环

优势：

* 可以处理负权边
* 能够检测出图中是否存在负权环

注意点：

* 松弛一次可以得到起点到与起点相邻的顶点的最短距离，也就是说可以得到起点到与起点仅用一条边相连的顶点的距离；那么松弛2次就可以得到起点到与起点用2条边相连的顶点的最短板距离。以此类推，松弛 v - 1 次就可以得到起点到终点的最短距离
* 顶点的数量设为v，起点到终点最多有 v - 1 条边相连。无论图是什么样的，只要松弛了 v - 1次就一定可以得到起点到终点的最短距离
* 进行 v - 1 次松弛操作后，minDist[]数组可以得到起点到任意其他顶点的最短距离；这与Dijkstra算法是一致的
* Bellman-Ford算法最多需要 v - 1 次松弛操作就能得到最短路径，再多几次松弛操作也不会改变 minDist[]数组，有些图可以在松弛操作进行 v - 1 次前得到最短路径
