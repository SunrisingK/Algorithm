## 不定长滑动窗口

### 1. 核心概念：一个可以伸缩的“窗口”

想象一下，你有一个数组或字符串（我们称之为序列），你的任务是在这个序列上找到一个满足某种条件的连续子序列。

**不定长滑动窗口**  technique 就是使用两个指针（通常是 `left` 和 `right`）来动态地定义一个窗口的范围：

- **`left` 指针**： 定义窗口的左边界。
- **`right` 指针**： 定义窗口的右边界。

这个窗口的“不定长”体现在：`left` 和 `right` 指针的移动是独立的、不同步的，它们会根据当前窗口内的状态动态调整，从而使窗口的大小不断扩大或缩小。

---

### 2. 工作原理与步骤（枚举右维护左）

不定长滑动窗口算法通常遵循一个经典的循环结构：

1. **初始化**： 将 `left` 和 `right` 指针都置于序列的起始位置（例如，索引 0）。此时窗口 `[left, right]` 不包含任何元素（如果区间是左闭右开）或只包含一个元素。
2. **外层循环移动右指针**： 我们用一个循环（通常是 `for` 循环）来逐步将 `right` 指针向右移动。每次移动，都将 `nums[right]` 包含进当前窗口。

   - 这相当于**扩大窗口**，探索更多的可能性。
3. **更新窗口状态**： 当新元素加入窗口后，更新与问题相关的状态变量（例如，窗口内元素的和、字符出现的频率、唯一元素的个数等）。
4. **内层循环移动左指针（收缩窗口）**： 在移动 `right` 指针后，通常需要一个 `while` 循环来检查**当前窗口是否满足了需要收缩的条件**（例如，窗口内的元素和超过了目标值，或者包含了重复字符）。

   - 如果条件满足，我们就将 `left` 指针向右移动，并将 `nums[left]` 从窗口中移除。
   - 同时，更新相关的状态变量。
   - 这个循环会一直执行，直到窗口再次变得“合法”或“满足条件”。
5. **记录答案**： 在窗口的每一次合法状态下（通常在收缩循环之后，窗口是满足条件的），根据题目要求更新最终答案（例如，记录当前窗口的长度是否是最小的，或者是否是最大的）。

---

### 3. 一个例子：找最短的“水果摊”

**问题**： 你沿着一条街走，街上有一排水果摊。每个摊位只卖苹果(A)或橘子(O)。你想找到一个最短的连续摊位序列，使得这个序列里**至少有一个苹果和一个橘子**。

序列： `[A, O, O, A, O]`

我们用滑动窗口来解决：

1. **初始化**： `left = 0`, `right = 0`，窗口 `[0, 0)` 为空。
2. **移动 right**:
   - `right=0`： 窗口 `[A]`。只有苹果，没有橘子，继续。
   - `right=1`： 窗口 `[A, O]`。有苹果和橘子了！这是一个有效窗口，长度为2。记录一下。
3. **尝试移动 left (收缩)**： 现在窗口有效，我们看看能不能缩小它。
   - 移动 `left` 到 1： 窗口 `[O]`。只有橘子了，无效。停止收缩。`left` 回到 1。
4. **继续移动 right**:
   - `right=2`： 窗口 `[O, O]`。无效，继续。
   - `right=3`： 窗口 `[O, O, A]`。有效了，长度为3。比之前记录的2长，所以不更新答案。
   - **再次尝试收缩**： 移动 `left` 到 2： 窗口 `[O, A]`。仍然有效，长度为2。更新最佳答案？不，它和我们第一次发现的一样好（都是2）。
   - 继续移动 `left` 到 3： 窗口 `[A]`。无效。停止收缩。
5. **最后移动 right**:
   - `right=4`： 窗口 `[A, O]`。有效，长度为2。答案依然是2。

最终，我们找到的最短序列长度为2（比如 `[A, O]` 或 `[O, A]`）。

---

### 4. 经典应用场景

不定长滑动窗口非常适合解决一类 **“连续子数组/子串”** 问题。

1. **长度最小的子数组**

   - **问题**： 找到和 ≥ target 的长度最小的连续子数组。
   - **窗口用法**： 右指针扩大窗口以增加和。当和 ≥ target 时，左指针收缩窗口以寻找更小的长度，同时更新最小长度。
2. **无重复字符的最长子串**

   - **问题**： 找到不含有重复字符的最长子串。
   - **窗口用法**： 右指针扩大窗口，将新字符加入。当发现重复字符时（用哈希集合检查），左指针收缩窗口，从左侧移出字符，直到重复消失。在每次扩张后记录窗口的最大长度。
3. **字符串的排列**

   - **问题**： 判断字符串 s2 是否包含 s1 的排列。
   - **窗口用法**： 维护一个固定长度（s1的长度）的窗口在s2上滑动，但用不定长窗口的思路来构建和移动这个固定窗口，通过比较字符频率来判断。
4. **覆盖最小子串**

   - **问题**： 在字符串 S 中找到一个最短的子串，使其包含字符串 T 中的所有字符。
   - **窗口用法**： 右指针扩大窗口直到包含了T的所有字符，然后左指针收缩窗口以剔除不必要的字符，寻找最短的那个。

---

### 5. 算法模板（伪代码）

以下是一个通用的模板，大多数不定长滑动窗口问题都可以套用：

```cpp
// cpp
// 通用不定长滑动窗口模板
int slidingWindowTemplate(const vector<int>& nums, int target) {
    int left = 0;
    int result = INT_MAX; // 或 INT_MIN，根据问题需求
    int windowSum = 0;    // 窗口状态变量，根据具体问题定义
  
    for (int right = 0; right < nums.size(); right++) {
        // 1. 将右指针元素加入窗口，更新窗口状态
        windowSum += nums[right];
  
        // 2. 当窗口满足收缩条件时
        while (windowConditionMet(windowSum, target)) {
            // 3. 有些问题可能需要在while()代码内部更新答案
            result = min(result, right - left + 1);
  
            // 4. 将左指针元素移出窗口，更新窗口状态
            windowSum -= nums[left];
            left++; // 收缩窗口
        }
  
        // 注意：有些问题可能需要在while()代码后更新答案
    }
  
    return result == INT_MAX ? 0 : result; // 根据问题需求返回
}
```

```java
// Java
public class SlidingWindowTemplate {
    // 通用不定长滑动窗口模板
    public int slidingWindowTemplate(int[] nums, int target) {
        int left = 0;
        int result = Integer.MAX_VALUE; // 或 Integer.MIN_VALUE
        int windowState = 0; // 窗口状态变量
  
        for (int right = 0; right < nums.length; right++) {
            // 1. 将右指针元素加入窗口
            windowState = addToWindow(windowState, nums[right]);
  
            // 2. 当窗口满足收缩条件时
            while (isWindowValid(windowState, target)) {
                // 3. 有些问题可能需要在while()代码内部更新答案
                result = Math.min(result, right - left + 1);
  
                // 4. 将左指针元素移出窗口
                windowState = removeFromWindow(windowState, nums[left]);
                left++; // 收缩窗口
            }
  
            // 注意：有些问题可能需要在while()代码后更新答案
        }
  
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

### 总结

| 特性               | 描述                                                                                                      |
| :----------------- | :-------------------------------------------------------------------------------------------------------- |
| **核心思想** | 通过两个指针动态维护一个序列上的窗口，通过移动指针来探索所有可能的解，避免暴力枚举                        |
| **关键点**   | 右指针用于**探索和扩大**窗口，左指针用于**优化和收缩**窗口                                    |
| **优势**     | 将许多原本需要 O(N²) 的暴力算法优化到**O(N)** 的时间复杂度，因为每个元素最多被放入和移出窗口各一次 |
| **适用问题** | 寻找满足特定条件的**连续子数组/子串**，如最值问题、包含问题等                                       |
